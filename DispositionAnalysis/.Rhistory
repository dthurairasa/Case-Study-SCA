combined_MAPE = sum(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), mean(abs((as.numeric(forecast_Peking$x - forecast_Peking$fitted)/as.numeric(forecast_Peking$x)) * 100)), mean(abs((as.numeric(forecast_Philippinen$x - forecast_Philippinen$fitted)/as.numeric(forecast_Philippinen$x)) * 100)), mean(abs((as.numeric(forecast_Shanghai$x - forecast_Shanghai$fitted)/as.numeric(forecast_Shanghai$x)) * 100)), mean(abs((as.numeric(forecast_SouthKorea$x - forecast_SouthKorea$fitted)/as.numeric(forecast_SouthKorea$x)) * 100)))
nachfrage_25_3
combined_MAPE
cat("Die forecast für die Nachfrage im 3. Quartal von 2025 ist ", round(nachfrage_25_3, 0), "Stück.\nAllerdings ist dies nur eine Nachfrageschaetzung basierend auf den bisherigen Werten! \nDer kombinierte durchschnittliche prozentuale Fehler ist ", round(combined_MAPE, 2), "% und das heißt, \ndass die tatsaechlige Nachfrage wahrscheinlich um ", round(nachfrage_25_3*(combined_MAPE/100), 0) , "Stueck abweichen wird.")
nachfrage_25_3 = sum(forecast_Japan$mean[7:9], forecast_Philippinen$mean[7:9], forecast_Peking$mean[7:9], forecast_Shanghai$mean[7:9], forecast_SouthKorea$mean[7:9])
combined_MAPE = sum(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), mean(abs((as.numeric(forecast_Peking$x - forecast_Peking$fitted)/as.numeric(forecast_Peking$x)) * 100)), mean(abs((as.numeric(forecast_Philippinen$x - forecast_Philippinen$fitted)/as.numeric(forecast_Philippinen$x)) * 100)), mean(abs((as.numeric(forecast_Shanghai$x - forecast_Shanghai$fitted)/as.numeric(forecast_Shanghai$x)) * 100)), mean(abs((as.numeric(forecast_SouthKorea$x - forecast_SouthKorea$fitted)/as.numeric(forecast_SouthKorea$x)) * 100)))
nachfrage_25_3
combined_MAPE
cat("Die forecast für die Nachfrage im 3. Quartal von 2025 ist ", round(nachfrage_25_3, 0), "Stueck.\nAllerdings ist dies nur eine Nachfrageschaetzung basierend auf den bisherigen Werten! \nDer kombinierte durchschnittliche prozentuale Fehler ist ", round(combined_MAPE, 2), "% und das heißt, \ndass die tatsaechlige Nachfrage wahrscheinlich um ", round(nachfrage_25_3*(combined_MAPE/100), 0) , "Stueck in die eine oder andere Richtung abweichen wird.")
nachfrage_25_3 = sum(forecast_Japan$mean[7:9], forecast_Philippinen$mean[7:9], forecast_Peking$mean[7:9], forecast_Shanghai$mean[7:9], forecast_SouthKorea$mean[7:9])
combined_MAPE = sum(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), mean(abs((as.numeric(forecast_Peking$x - forecast_Peking$fitted)/as.numeric(forecast_Peking$x)) * 100)), mean(abs((as.numeric(forecast_Philippinen$x - forecast_Philippinen$fitted)/as.numeric(forecast_Philippinen$x)) * 100)), mean(abs((as.numeric(forecast_Shanghai$x - forecast_Shanghai$fitted)/as.numeric(forecast_Shanghai$x)) * 100)), mean(abs((as.numeric(forecast_SouthKorea$x - forecast_SouthKorea$fitted)/as.numeric(forecast_SouthKorea$x)) * 100)))
cat("Die forecast für die Nachfrage im 3. Quartal von 2025 ist ", round(nachfrage_25_3, 0), "Stueck.\nAllerdings ist dies nur eine Nachfrageschaetzung basierend auf den bisherigen Werten! \nDer kombinierte durchschnittliche prozentuale Fehler ist ", round(combined_MAPE, 2), "% und das heißt, \ndass die tatsaechlige Nachfrage wahrscheinlich um ", round(nachfrage_25_3*(combined_MAPE/100), 0) , "Stueck in die eine oder andere Richtung abweichen wird.")
# Tatsächlicher Januarwert 2023 (Index 37)
actual_jan_2023 <- forecast_Japan$x[37]
# Andere Januarwerte: 2020, 2021, 2022, 2024 → Indizes 1, 13, 25, 49
actual_jan_others <- mean(forecast_Japan$x[c(1, 13, 25, 49)])
# Forecast für Januar 2025 (1. Monat im Forecast)
forecast_jan_2025 <- forecast_Japan$mean[1]
# Ausgabe
cat("Tatsächlicher Wert Januar 2023:", actual_jan_2023, "\n")
cat("Andere tatsächliche Januar-Werte (2020–2022, 2024):", actual_jan_others, "\n")
cat("Forecast-Wert für Januar 2025:", forecast_jan_2025, "\n")
cat("Tatsächlicher Wert Januar 2023:", forecast_Japan$x[37], "\n")
cat("Andere tatsächliche Januar-Werte (2020–2022, 2024):", mean(forecast_Japan$x[c(1, 13, 25, 49)]), "\n")
cat("Forecast-Wert für Januar 2025:", forecast_Japan$mean[1], "\n")
cat("Die tatsächliche Nachfrage Januar 2023 in Japan war ", forecast_Japan$x[37], "Stueck.\nIm Januar wurden in den restlichen Jahren durchschnittlich ", mean(forecast_Japan$x[c(1, 13, 25, 49)]), "Stueck nachgefragt.\n D.h., dass im Januar 2023 die Nachfrage tatsaechlich nicht niedriger war als sonst sogar etwas hoeher als in den restlichen Januaren.")
cat("Forecast-Wert für Januar 2025:", forecast_Japan$mean[1], "\n")
cat("Die tatsächliche Nachfrage Januar 2023 in Japan war ", forecast_Japan$x[37], "Stueck.\nIm Januar wurden in den restlichen Jahren durchschnittlich ", round(mean(forecast_Japan$x[c(1, 13, 25, 49)]), 0), "Stueck nachgefragt.\n D.h., dass im Januar 2023 die Nachfrage tatsaechlich nicht niedriger war als sonst sogar etwas hoeher als in den restlichen Januaren.")
cat("Forecast-Wert für Januar 2025:", forecast_Japan$mean[1], "\n")
cat("Die tatsaechliche Nachfrage Januar 2023 in Japan war ", forecast_Japan$x[37], "Stueck.\nIm Januar wurden in den restlichen Jahren durchschnittlich ", round(mean(forecast_Japan$x[c(1, 13, 25, 49)]), 0), "Stueck nachgefragt.\n D.h., dass im Januar 2023 die Nachfrage tatsaechlich nicht niedriger war als sonst sogar etwas hoeher als in den restlichen Januaren.\n Das Modell errechnet für Januar 2025 einen Forecast-Wert von ", round(forecast_Japan$mean[1], 0), "Stueck.\n")
cat("Der MFE ist: ", round(mean(as.numeric(forecast_Japan$x - forecast_Japan$fitted)), 2), "\n")
cat("Der MAE ist: ", round(mean(abs(as.numeric(forecast_Japan$x - forecast_Japan$fitted))), 2), "\n")
cat("Der MSE ist: ", round(mean((as.numeric(forecast_Japan$x - forecast_Japan$fitted)^2)), 2), "\n")
cat("Der MAPE ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "\n")
cat("Sowohl der MAE, MAPE und MSE sind valide Kennzahlen um die Forecast zu bewerten, da sich \npositive und negative Fehler nicht wie beim MFE ausgleichen können. \nDer MSE waere die beste Kennzahl wenn man erhoehten Wert auf besonders große Fehler legt. \nWenn dies nicht der fall ist, sollte der MAE oder MAPE am wichtigsten erahchtet werden.")
#Laden der Daten
services = read.csv2("output_services_v0028.csv")
transactions = read.csv2("output_transactions_v0028.csv")
# Ausschliessen der Datensaetze ausserhalb von 2020-2024
transactions = subset(transactions, Year >= 2020 & Year <= 2024 )
services = subset(services, Year >= 2020 & Year <= 2024 )
#Grpfiklibrary loaden
library("zoo")
library("forecast")
library("ggplot2")
View(services)
View(transactions)
#Laden der Daten
transactions = read.csv2("output_transactions_v0028.csv")
# Ausschliessen der Datensaetze ausserhalb von 2020-2024
transactions = subset(transactions, Year >= 2020 & Year <= 2024)
#Grpfiklibrary loaden
library("zoo")
library("forecast")
library("ggplot2")
transactions$Period = sprintf("%04d-%02d", transactions$Year, transactions$Month)
Demand = aggregate(Sales ~ Period + region, transactions, sum)
colnames(Demand) = c("Period", "Region", "Demand")
head(Demand)
View(Demand)
DemandWide = reshape(Demand, timevar = "Region", idvar = "Period", direction = "wide")
head(DemandWide)
DemandWide = reshape(Demand, timevar = "Region", idvar = "Period", direction = "wide")
colnames(DemandWide) = c("Period", "DemandInJapan", "DemandInPeking", "DemandInPhlppn", "DemandInShangh", "DemandInSkorea")
head(DemandWide)
ts_Japan = ts(DemandWide$Demand.Japan, frequency = 12)
ts_Japan = ts(DemandWide$DemandInJapan, frequency = 12)
ts_Peking = ts(DemandWide$DemandInPeking, frequency = 12)
ts_Phlppn = ts(DemandWide$DemandInPhlppn, frequency = 12)
ts_Shangh = ts(DemandWide$DemandInShangh, frequency = 12)
ts_Skorea = ts(DemandWide$DemandInSkorea, frequency = 12)
Demand$Date <- as.Date(paste0(Demand$Period, "-01"))
ggplot(Demand, aes(x = Date, y = Demand, color = Region)) +
geom_line(linewidth = 0.6) +
labs(title = "Nachfrageverlauf",
x = "Zeit in Jahren", y = "Nachfrage in Stückzahl") +
scale_color_manual(values = c("violetred", "cadetblue2", "deepskyblue", "turquoise3", "seagreen1")) +
scale_x_date(date_breaks = "1 year", date_labels = "%Y")+
theme_minimal()
model_Japan = ets(ts_Japan, model = "ZZZ")
summary(model_Japan)
model_Japan$x
residuals(model_Japan)
cat("Der Durchschnittswert für die monatliche Nachfrage im Jahr 2024 betraegt: " , mean(tail(model_Japan$x, 12)), "\n")
cat("Der Durchschnittswert für die monatliche Nachfrage des Modells im Jahr 2024 betraegt: " , mean(tail(fitted(model_Japan), 12)), "\n")
cat("Wenn man 2024 schon die Modellwerte genutzt hätte, hätte man durchschnittlich 91 Flaschen \nzu wenig geliefert. \nDas entspricht ", round((1 - (mean(tail(fitted(model_Japan), 12)) / mean(tail(model_Japan$x, 12))))*100, 2), "% der durchschnittlichen Originalnachfrage. \n Obwohl in den Jahren zuvor(2020-2023) der allgemeine Trend der Originalwerte nach unten geht, \n ist die Abweichung für das in den Originaldaten nachfragehoehere Jahr 2024 relativ klein. ")
forecast_Japan = forecast(model_Japan, h = 12)
cat("Der MFE ist: ", round(mean(as.numeric(forecast_Japan$x - forecast_Japan$fitted)), 2), "\n")
cat("Der MAE ist: ", round(mean(abs(as.numeric(forecast_Japan$x - forecast_Japan$fitted))), 2), "\n")
cat("Der MSE ist: ", round(mean((as.numeric(forecast_Japan$x - forecast_Japan$fitted)^2)), 2), "\n")
cat("Der MAPE ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "\n")
cat("Sowohl der MAE, MAPE und MSE sind valide Kennzahlen um die Forecast zu bewerten, da sich \npositive und negative Fehler nicht wie beim MFE ausgleichen können. \nDer MSE waere die beste Kennzahl wenn man erhoehten Wert auf besonders große Fehler legt. \nWenn dies nicht der fall ist, sollte der MAE oder MAPE am wichtigsten erahchtet werden.")
model_Japan_ANA = ets(ts_Japan, model = "ANA")
forecast_Japan_ANA = forecast(model_Japan_ANA, h = 12)
cat("Der MAPE mit den ZZZ-Parametern ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "%.\n")
cat("Der MAPE mit den ANA-Parametern ist: ", round(mean(abs((as.numeric(model_Japan_ANA$x - model_Japan_ANA$fitted)/as.numeric(model_Japan_ANA$x)) * 100)), 2), "%.\n")
cat("Das heißt das Modell ist mit den ZZZ-Parametern nach Wertung mit dem MAPE besser \nals das Modell mit den ANA-Parametern.\nDies muss aber nicht immer der Fall sein, da die ets-Funktion bei ZZZ-Parametern nicht nach dem MAPE entscheidet.\n Die ets-Funktion entscheidet das Modell nach der eingebetteten Entscheidungslogik(AIC), \nsodass nach Dieser andere Parameter als ANA gewaehlt werden koennen \nobwohl die ANA-Parameter den niedrigsten MAPE erzeugen. \nDas heißt weder Doug noch Cassie haben recht. \nDie ANA-Parameter diesmal sind nicht besser, aber die ZZZ-Parameter sind auch nicht immer besser.")
forecast_Japan = forecast(model_Japan, h = 12)
cat("Der MFE ist: ", round(mean(as.numeric(forecast_Japan$x - forecast_Japan$fitted)), 2), "\n")
cat("Der MAE ist: ", round(mean(abs(as.numeric(forecast_Japan$x - forecast_Japan$fitted))), 2), "\n")
cat("Der MSE ist: ", round(mean((as.numeric(forecast_Japan$x - forecast_Japan$fitted)^2)), 2), "\n")
cat("Der MAPE ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "\n")
cat("Sowohl der MAE, MAPE und MSE sind valide Kennzahlen um eine Forecast zu bewerten, da sich \npositive und negative Fehler nicht wie beim MFE ausgleichen können. \nDer MSE ist unserer Meinung nach nicht die beste Kennzahl, weil es erhoehten Wert auf besonders große Fehler legt. \nWenn dies nicht der fall ist, sollte der MAE oder MAPE als am wichtigsten erahchtet werden.")
cat("Der MAPE des Modells von Japan ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "%.\n")
model_Peking = ets(ts_Peking, model = "ZZZ")
forecast_Peking = forecast(model_Peking, h = 12)
cat("Der MAPE des Modells von Peking ist: ", round(mean(abs((as.numeric(forecast_Peking$x - forecast_Peking$fitted)/as.numeric(forecast_Peking$x)) * 100)), 2), "%.\n")
model_Philippinen = ets(ts_Phlppn, model = "ZZZ")
forecast_Philippinen = forecast(model_Philippinen, h = 12)
cat("Der MAPE des Modells von Philippinen ist: ", round(mean(abs((as.numeric(forecast_Philippinen$x - forecast_Philippinen$fitted)/as.numeric(forecast_Philippinen$x)) * 100)), 2), "%.\n")
model_Shanghai = ets(ts_Shangh, model = "ZZZ")
forecast_Shanghai = forecast(model_Shanghai, h = 12)
cat("Der MAPE des Modells von Sanghai ist: ", round(mean(abs((as.numeric(forecast_Shanghai$x - forecast_Shanghai$fitted)/as.numeric(forecast_Shanghai$x)) * 100)), 2), "%.\n")
model_SouthKorea = ets(ts_Skorea, model = "ZZZ")
forecast_SouthKorea = forecast(model_SouthKorea, h = 12)
cat("Der MAPE des Modells von SouthKorea ist: ", round(mean(abs((as.numeric(forecast_SouthKorea$x - forecast_SouthKorea$fitted)/as.numeric(forecast_SouthKorea$x)) * 100)), 2), "%.\n")
cat("Laut dem MAPE, eignet sich das Modell am besten um die Nachfrage von Peking zu Modellieren. \nDer MAPE von Peking ist mit ", round(mean(abs((as.numeric(forecast_Peking$x - forecast_Peking$fitted)/as.numeric(forecast_Peking$x)) * 100)), 2), "% der niedrigste.")
cat("Die tatsaechliche Nachfrage Januar 2023 in Japan war ", forecast_Japan$x[37], "Stueck.\nIm Januar wurden in den restlichen Jahren durchschnittlich ", round(mean(forecast_Japan$x[c(1, 13, 25, 49)]), 0), "Stueck nachgefragt.\n D.h., dass im Januar 2023 die Nachfrage tatsaechlich nicht niedriger war als sonst sogar \netwas hoeher als in den restlichen Januaren.\n Das Modell errechnet für Januar 2025 einen Forecast-Wert von ", round(forecast_Japan$mean[1], 0), "Stueck.\n Das heisst die Nachfrage in 2025 sollte etwas niedriger sein als im Januar 2023.")
cat("Die tatsaechliche Nachfrage Januar 2023 in Japan war ", forecast_Japan$x[37], "Stueck.\nIm Januar wurden in den 5 Jahren durchschnittlich ", round(mean(forecast_Japan$x[c(1, 13, 25, 37,49)]), 0), "Stueck nachgefragt.\n D.h., dass im Januar 2023 die Nachfrage tatsaechlich nicht niedriger war als sonst sogar \netwas hoeher als im Durchschnitt.\n Das Modell errechnet für Januar 2025 einen Forecast-Wert von ", round(forecast_Japan$mean[1], 0), "Stueck.\n Das heisst die Nachfrage in 2025 sollte etwas niedriger sein als im Januar 2023.")
forecast_Japan = forecast(model_Japan, h = 12)
cat("Der MFE ist: ", round(mean(as.numeric(forecast_Japan$x - forecast_Japan$fitted)), 2), "\n")
cat("Der MAE ist: ", round(mean(abs(as.numeric(forecast_Japan$x - forecast_Japan$fitted))), 2), "\n")
cat("Der MSE ist: ", round(mean((as.numeric(forecast_Japan$x - forecast_Japan$fitted)^2)), 2), "\n")
cat("Der MAPE ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "\n")
cat("Sowohl der MAE, MAPE und MSE sind valide Kennzahlen um eine Forecast zu bewerten, da sich \npositive und negative Fehler nicht wie beim MFE ausgleichen können. \n Am vergleich vom MFE mit 14.11 und MAE von 351.84 erkennt man dies auch gut. \nDer MSE ist unserer Meinung nach nicht die beste Kennzahl, weil es erhoehten Wert auf besonders große Fehler legt\n und mit 235733.2 eine sehr hohe Zahl aufgrund der saisonalen Extreme liefert. \nWenn dies nicht der fall ist, sollte der MAE oder MAPE als am wichtigsten erahchtet werden.")
forecast_Japan = forecast(model_Japan, h = 12)
cat("Der MFE ist: ", round(mean(as.numeric(forecast_Japan$x - forecast_Japan$fitted)), 2), "\n")
cat("Der MAE ist: ", round(mean(abs(as.numeric(forecast_Japan$x - forecast_Japan$fitted))), 2), "\n")
cat("Der MSE ist: ", round(mean((as.numeric(forecast_Japan$x - forecast_Japan$fitted)^2)), 2), "\n")
cat("Der MAPE ist: ", round(mean(abs((as.numeric(forecast_Japan$x - forecast_Japan$fitted)/as.numeric(forecast_Japan$x)) * 100)), 2), "\n")
cat("Sowohl der MAE, MAPE und MSE sind valide Kennzahlen um eine Forecast zu bewerten, da sich \npositive und negative Fehler nicht wie beim MFE ausgleichen können. \n Am vergleich vom MFE mit 14.11 und MAE von 351.84 erkennt man dies auch gut. \nDer MSE ist unserer Meinung nach nicht die beste Kennzahl, weil es erhoehten Wert auf besonders große Fehler legt\n und mit 235733.2 eine sehr hohe Zahl aufgrund der saisonalen Extreme liefert. \n Der MAE oder MAPE liefern gute Kennzahlen und zeigen, dass die Forecast füuer Japan mit diesen Werten sehr gut ist. \n Ob die absolute Menge in Stueck des MAE (351.84) oder die prozentuale Abweichung \n des MAPE (2.01) besser sind ist von der geplanten Anwendung abhängig.")
cat("Durch den relativ geringen MAE vergleichsweise zur Nachfrage und den geringen MAPE \nwird unsere Annahme aus Aufgabe 5 bestaetigt:\nWie vermutet ist das Holt-Winter-Modell geeignet um den Verlauf der Nachfrage \nfür Japan zu modellieren. \nAllerdings wird der leichte Trend von 2020 - 2023 entgegen der Erwartungen nicht \nbemerkbar beruecksichtigt.")
library("fastDummies")
library("ggplot2")
library("Metrics")
library("GGally")
# Lader der Daten
bikes = read.csv2("10_Problem_Set_10-2.csv")
#Zusammenfassung (NULL ersetzen)
summary(bikes)
#Struktur der Daten (NULL ersetzen)
str(bikes)
# gegebenenfalls bestimmte Variablen als factor typecasten (dient primaer der uebersichtlichkeit) (NULL ersetzen)
bikes$season = as.factor(bikes$season)
bikes$yr = as.factor(bikes$yr)
bikes$mnth = as.factor(bikes$mnth)
bikes$weekday = as.factor(bikes$weekday)
bikes$weathersit = as.factor(bikes$weathersit)
# Zusammenfassung erneut anzeigen (NULL ersetzen)
summary(bikes)
# Baseline durch Mittelwert erzeugen (NULL ersetzen)
bikes$Baseline = mean(bikes$casual)
# Anzeigen der Daten (nur Kopf, nur relevante Variablen) (NULL ersetzen)
head(bikes[, c("casual","Baseline")])
# Data Frame fuer Evaluation neu aufbauen
evaluation = data.frame(Model = "Baseline",
Rsquared = numeric(1),
MAE = numeric(1),
MSE = numeric(1),
sMAPE = numeric(1))
# MFE berechnen
evaluation[evaluation$Model == "Baseline",]$Rsquared = NA
# MAE berechnen
evaluation[evaluation$Model == "Baseline",]$MAE = mean(abs(bikes$casual - bikes$Baseline))
# MSE berechnen
evaluation[evaluation$Model == "Baseline",]$MSE = mean((bikes$casual - bikes$Baseline)^2)
# sMAPE berechnen
evaluation[evaluation$Model == "Baseline",]$sMAPE = smape(bikes$casual, bikes$Baseline)
# Fehler anzeigen
evaluation
# jeweils NULL ersetzen
# season
cat("season:\n")
tapply(bikes$casual, bikes$season, mean)
# yr
cat("yr:\n")
tapply(bikes$casual, bikes$yr, mean)
# holiday
cat("holiday:\n")
tapply(bikes$casual, bikes$holiday, mean)
# workingday
cat("workingday:\n")
tapply(bikes$casual, bikes$workingday, mean)
# weathersit
cat("weathersit:\n")
tapply(bikes$casual, bikes$weathersit, mean)
#jeweils NULL ersetzen
#hr
ggplot(bikes, aes(x = hr, y = casual)) + geom_col()
# weekday
ggplot(bikes, aes(x = weekday, y = casual)) + geom_col()
#jeweils NULL ersetzen
# temp
ggplot(bikes, aes(x = temp, y = casual)) + geom_point() + geom_smooth()
# atemp
ggplot(bikes, aes(x = atemp, y = casual)) + geom_point() + geom_smooth()
# hum
ggplot(bikes, aes(x = hum, y = casual)) + geom_point() + geom_smooth()
# windspeed
ggplot(bikes, aes(x = windspeed, y = casual)) + geom_point() + geom_smooth()
# KOMMENTAR ersetzen, indem die Zusammenhaenge oben betrachtetn werden
# gegebenenfalls NULL ersetzen, um eine Transformation vorzunehmen
# season
# Season 2 und 3 (Fruehling und Sommer) scheinen einen positiven Einfluss zu haben
bikes$season2or3 = as.numeric(bikes$season == 2 | bikes$season == 3)
# yr
# Zum zweiten Jahr gab es einen deutlichen positiven Trend.
# holiday
# an Ferientagen scheinen mehr Fahrraeder nachgefragt zu werden
# workingday
# an Arbeitstagen scheinen weniger Fahrraeder nachgefragt zu werden
# weathersit
# je nach Wettersituation scheinen unterschiedlich viele Fahrraeder nachgefragt zu werden
bikes = dummy_cols(bikes, select_columns = "weathersit")
# weekday
# an den Tagen 0 und 6 (Samstag und Sonntag) scheinen deutlich mehr Fahrraeder nachgefragt zu werden
bikes$weekend = as.numeric(bikes$weekday == 0 | bikes$weekday == 6)
# KOMMENTAR ersetzen, indem die Zusammenhaenge oben betrachtetn werden
# gegebenenfalls NULL ersetzen, um eine Transformation vorzunehmen
# season
# Season 2 und 3 (Fruehling und Sommer) scheinen einen positiven Einfluss zu haben
bikes$season2or3 = as.numeric(bikes$season == 2 | bikes$season == 3)
# yr
# Zum zweiten Jahr gab es einen deutlichen positiven Trend.
# holiday
# an Ferientagen scheinen mehr Fahrraeder nachgefragt zu werden
# workingday
# an Arbeitstagen scheinen weniger Fahrraeder nachgefragt zu werden
# weathersit
# je nach Wettersituation scheinen unterschiedlich viele Fahrraeder nachgefragt zu werden
bikes = dummy_cols(bikes, select_columns = "weathersit")
# weekday
# an den Tagen 0 und 6 (Samstag und Sonntag) scheinen deutlich mehr Fahrraeder nachgefragt zu werden
bikes$weekend = as.numeric(bikes$weekday == 0 | bikes$weekday == 6)
# Veraendern Sie gegebenenfalls den Code, falls Sie andere Einteilungen fuer sinnvoller erachten
# Daten aufteilen
bikes$hr6hRange = cut(bikes$hr,
c(0, 6, 12, 18, 24),
right = FALSE,
labels = c("0_5", "6_11", "12_17", "18_23"))
tapply(bikes$casual, bikes$hr6hRange, mean)
# Faktorvariable erzeugen
bikes = dummy_cols(bikes, select_columns = "hr6hRange")
# Bestimmen Sie die Korrelationskoeffizienten von der Zielvariable und saemtlichen relevanten unabhaengigen Variablen (NULL ersetzen)
cor(bikes$casual, bikes[,c(8,10,12:18,20:25,27:30)])
# Einen zufaelligen Zustand herstellen (der jedoch kontrolliert erstellt wird und daher wiederholbar ist)
set.seed(1337)
# eine Zufallsauswahl erstellen: Aus der Liste von Zahlen 1 bis Laenge von bikes werden 80% gewaehlt
# Antwort (NA ersetzen):
zufall = sample(1:nrow(bikes), nrow(bikes) * 0.8)
# Die Eintraege in der Zufallsauswahl gehen in das TrainingsSet
# Antwort (NA ersetzen):
bikes_train = bikes[zufall, ]
# Die Eintraege nicht in der Zufallsauswahl gehen in das TestSet
# Antwort (NA ersetzen):
bikes_test = bikes[-zufall, ]
# ab hier ist Ihnen das Vorgehen nicht weiter vorgegeben. Versuchen Sie bis zum Ende der Bearbeitungszeit das bestmoegliche Modell zu erstellen
# Achten Sie bei der Auswahl der Variablen auf die Vermeidung von Multikollinearitaet
# Testen Sie Ihr finales Modell ausserdem auf Overfitting
# Die Loesung aus der Lsg-Datei folgt keinem strikten Vorgehen und ist daher nur als beispielhafte Loesung und nicht als "Musterloesung" zu sehen.
#Modell 1 mit allen Variablen:
m1 = lm(casual ~ yr + temp + workingday + weathersit_1 + weathersit_2 + weathersit_3 + weathersit_4 + hum + season2or3 + hr6hRange_0_5 + hr6hRange_12_17 , data = bikes_train)
# Anzeigen des Modells
summary(m1)
# evalation data frame erweitern
evaluation = rbind(evaluation, data.frame(Model = c("m1"),
Rsquared = numeric(1),
MAE = numeric(1),
MSE = numeric(1),
sMAPE = numeric(1)))
# MFE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m1",]$Rsquared = summary(m1)$r.squared
# MAE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m1",]$MAE = mean(abs(m1$residuals))
# MSE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m1",]$MSE = mean((m1$residuals)^2)
# sMAPE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m1",]$sMAPE = smape(m1$model$casual, m1$fitted.values)
# Fehler anzeigen
evaluation
#Modell 2 mit reduzierten Variablen (nicht signifikante p-values raus)
m2 = lm(casual ~ yr + temp + workingday + hum + hr6hRange_0_5 + hr6hRange_12_17 , data = bikes_train)
# Anzeigen des Modells
summary(m2)
# evalation data frame erweitern
evaluation = rbind(evaluation, data.frame(Model = c("m2"),
Rsquared = numeric(1),
MAE = numeric(1),
MSE = numeric(1),
sMAPE = numeric(1)))
# MFE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2",]$Rsquared = summary(m2)$r.squared
# MAE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2",]$MAE = mean(abs(m2$residuals))
# MSE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2",]$MSE = mean((m2$residuals)^2)
# sMAPE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2",]$sMAPE = smape(m2$model$casual, m2$fitted.values)
# Fehler anzeigen
evaluation
# Vorhersage erzeugen
# Antwort (NA ersetzen):
pred2 = predict(m2, bikes_test)
# Data Frame erweitern
evaluation = rbind(evaluation, data.frame(Model = c("m2_test"),
Rsquared = numeric(1),
MAE = numeric(1),
MSE = numeric(1),
sMAPE = numeric(1)))
# MFE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2_test",]$Rsquared = NA
# MAE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2_test",]$MAE = mean(abs(bikes_test$casual - pred2))
# MSE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2_test",]$MSE = mean((bikes_test$casual - pred2)^2)
# sMAPE berechnen
# Antwort (NA ersetzen):
evaluation[evaluation$Model == "m2_test",]$sMAPE = smape(bikes_test$casual, pred2)
# Fehler anzeigen
evaluation
# Laden der Daten
Data = read_excel(file.choose())
library(readxl)
library("fastDummies")
library("ggplot2")
library("Metrics")
library("GGally")
# Laden der Daten
Data = read_excel(file.choose())
# Anzeigen der Daten (nur Kopf)
str(Data)
View(Data)
# Laden der Daten
Data = read_excel(file.choose())
# Anzeigen der Daten (nur Kopf)
str(Data)
# Count number of rows (orders) per MATRNR
bestellungen_pro_matrnr <- as.data.frame(table(Data$MATRNR))
# Optional: rename columns
colnames(bestellungen_pro_matrnr) <- c("MATRNR", "Anzahl_Bestellungen")
# Laden der Daten
Data = read_excel(file.choose())
# Anzeigen der Daten (nur Kopf)
str(Data)
# Count number of rows (orders) per MATRNR
bestellungen_pro_matrnr <- aggregate(. ~ MATRNR, data = Data, FUN = length)
View(Data)
# Laden der Daten
Data = read_excel(file.choose())
# Anzeigen der Daten (nur Kopf)
str(Data)
# Count number of rows (orders) per MATRNR
bestellungen_pro_matrnr <- aggregate(. ~ MATNR, data = Data, FUN = length)
# Laden der Daten
Data = read_excel(file.choose())
# Laden der Daten
Data = read_excel(file.choose())
# Anzeigen der Daten (nur Kopf)
str(Data)
Data$count <- 1
bestellungen_pro_matrnr <- aggregate(count ~ MATNR, data = Data, FUN = sum)
# Optional: rename columns
colnames(bestellungen_pro_matrnr) <- c("MATRNR", "Anzahl_Bestellungen")
# Optional: sort in descending order
bestellungen_pro_matrnr <- bestellungen_pro_matrnr[order(-bestellungen_pro_matrnr$Anzahl_Bestellungen), ]
View(bestellungen_pro_matrnr)
# Laden der Daten
Data2 = read_excel(file.choose())
Data2 = Data2[, c("MATRNR", "PLIFZ")]
# Laden der Daten
Data2 = read_excel(file.choose())
Data2 = Data2[, c("MATNR", "PLIFZ")]
merged_df <- merge(bestellungen_pro_matrnr, Data2, by = "MATRNR")
# Laden der Daten
Data2 = read_excel(file.choose())
Data2 = Data2[, c("MATNR", "PLIFZ")]
merged_df <- merge(bestellungen_pro_matrnr, Data2, by = "MATNR")
# Laden der Daten
Data = read_excel(file.choose())
Data$count <- 1
bestellungen_pro_matrnr <- aggregate(count ~ MATNR, data = Data, FUN = sum)
# Optional: rename columns
colnames(bestellungen_pro_matrnr) <- c("MATNR", "Anzahl_Bestellungen")
# Optional: sort in descending order
bestellungen_pro_matrnr <- bestellungen_pro_matrnr[order(-bestellungen_pro_matrnr$Anzahl_Bestellungen), ]
# Laden der Daten
Data2 = read_excel(file.choose())
Data2 = Data2[, c("MATNR", "PLIFZ")]
merged_df <- merge(bestellungen_pro_matrnr, Data2, by = "MATNR")
View(merged_df)
# Laden der Daten
Data2 = read_excel(file.choose())
Data2 = Data2[, c("MATNR", "PLIFZ")]
merged_df <- merge(bestellungen_pro_matrnr, Data2, by = "MATNR")
merged_df <- merged_df[order(-merged_df$Anzahl_Bestellungen), ]
View(merged_df)
# Laden der Daten
Data3 = read_excel(file.choose())
Data3 = Data2[, c("MATNR", "ERDAT")]
View(Data3)
View(Data3)
# Laden der Daten
Data3 = read_excel(file.choose())
Data3 = Data2[, c("MATNR", "ERDAT")]
View(Data3)
# Laden der Daten
Data3 = read_excel(file.choose())
Data3 = Data3[, c("MATNR", "ERDAT")]
merged_dates <- merge(merged_df, Data3, by = "MATNR")
merged_dates <- merged_dates[order(-merged_dates$Anzahl_Bestellungen), ]
View(merged_dates)
# Laden der Daten
Data3 = read_excel(file.choose())
Data3 = Data3[, c("MATNR", "ERDAT")]
merged_dates <- merge(merged_df, Data3, by = "MATNR")
merged_dates <- merged_dates[order(-merged_dates$Anzahl_Bestellungen), ]
str(merged_dates)
Data$ERDAT <- as.Date(Data$ERDAT, format = "%d.%m.%Y")
merged_dates$ERDAT <- as.Date(merged_dates$ERDAT, format = "%d.%m.%Y")
View(Data)
View(merged_dates)
shiny::runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
install.packages("colourpicker")
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
runApp('C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis')
setwd("C:/Users/larau/Desktop/Uni/Master/Semester1/supplyChainAnalytics/TVINN/Git_CaseStudy/casestudy/DispositionAnalysis")
shiny::runApp()
<<<<<<< HEAD
runApp()
runApp()
runApp()
shiny::runApp()
install.packages("shinydashboard")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
View(master)
View(orders)
View(master)
runApp()
View(master)
shiny::runApp()
View(orders)
View(orders)
View(orders)
View(master)
View(materials_ext)
View(EKKO)
View(EKPO)
View(EKPO)
View(EBAN)
View(master)
runApp()
View(master)
runApp()
View(EBAN)
runApp()
runApp()
View(master)
runApp()
runApp()
View(master)
runApp()
runApp()
View(master)
runApp()
View(master)
View(master)
shiny::runApp()
=======
>>>>>>> origin/UI-update
shiny::runApp()
runApp()
runApp()
